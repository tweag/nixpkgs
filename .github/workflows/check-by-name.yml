# Checks pkgs/by-name (see pkgs/by-name/README.md)
# using the nixpkgs-check-by-name tool (see pkgs/test/nixpkgs-check-by-name)
name: Check pkgs/by-name

# The pre-built tool is fetched from a channel,
# making it work predictable on all PRs.
on:
  # Using pull_request_target instead of pull_request avoids having to approve first time contributors
  pull_request_target

# The tool doesn't need any permissions, it only outputs success or not based on the checkout
permissions: {}

jobs:
  check:
    # This is x86_64-linux, for which the tool is always prebuilt on the nixos-* channels,
    # as specified in nixos/release-combined.nix
    runs-on: ubuntu-latest
    # This should take 1 minute at most, but let's be generous.
    # The default of 6 hours is definitely too long
    timeout-minutes: 10
    steps:
      - name: Resolving the merge commit
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # This checks for mergeability of a pull request as recommended in
          # https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-your-git-database?apiVersion=2022-11-28#checking-mergeability-of-pull-requests

          # Retry the API query this many times
          retryCount=3
          # Start with 5 seconds, but double every retry
          retryInterval=5
          while true; do
            echo "Checking whether the pull request can be merged"
            prInfo=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/"$GITHUB_REPOSITORY"/pulls/${{ github.event.pull_request.number }})
            mergeable=$(jq -r .mergeable <<< "$prInfo")
            mergedSha=$(jq -r .merge_commit_sha <<< "$prInfo")

            if [[ "$mergeable" == "null" ]]; then
              if (( retryCount == 0 )); then
                echo "Not retrying anymore, probably GitHub is having internal issues"
                exit 1
              else
                (( retryCount -= 1 )) || true

                # null indicates that GitHub is still computing whether it's mergeable
                # Wait a couple seconds before trying again
                echo "GitHub is still computing whether this PR can be merged, waiting $retryInterval seconds before trying again ($retryCount retries left)"
                sleep "$retryInterval"

                (( retryInterval *= 2 )) || true
              fi
            else
              break
            fi
          done

          if [[ "$mergeable" == "true" ]]; then
            echo "The PR can be merged, checking the merge commit $mergedSha"
          else
            echo "The PR cannot be merged, it has a merge conflict"
            exit 1
          fi
          echo "mergedSha=$mergedSha" >> "$GITHUB_ENV"
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
        with:
          # pull_request_target checks out the base branch by default
          ref: ${{ env.mergedSha }}
          # Fetches the merge commit and its parents
          fetch-depth: 2
      - name: Determining PR git hashes
        run: |
          # For pull_request_target this is the same as $GITHUB_SHA
          baseSha=$(git rev-parse HEAD^1)
          headSha=$(git rev-parse HEAD^2)

          base=$(mktemp -d)
          echo "base=$base" >> "$GITHUB_ENV"
          echo "Checking out the base branch ($baseSha) in a separate directory"
          git worktree add "$base" "$baseSha"

          # Print a markdown summary in GitHub actions
          {
            echo "### Details"
            echo "- Tested Nixpkgs:"
            echo "  - Base branch: $GITHUB_BASE_REF"
            echo "  - Latest base branch commit: [$baseSha](https://github.com/${GITHUB_REPOSITORY}/commit/$baseSha)"
            echo "  - Latest PR commit: [$headSha](https://github.com/${GITHUB_REPOSITORY}/commit/$headSha)"
            echo "  - Merge commit: [$mergedSha](https://github.com/${GITHUB_REPOSITORY}/commit/$mergedSha)"
          } >> "$GITHUB_STEP_SUMMARY"

      - uses: cachix/install-nix-action@7ac1ec25491415c381d9b62f0657c7a028df52a7 # v24
      - name: Determining channel to use for dependencies
        run: |
          echo "Determining the preferred channel to use for PR base branch $GITHUB_BASE_REF"
          if [[ "$GITHUB_BASE_REF" =~ ^(release|staging|staging-next)-([0-9][0-9]\.[0-9][0-9])$ ]]; then
              # Use the release channel for all PRs to release-XX.YY, staging-XX.YY and staging-next-XX.YY
              channel=nixos-${BASH_REMATCH[2]}
              echo "PR is for a release branch, preferred channel is $channel"
          else
              # Use the nixos-unstable channel for all other PRs
              channel=nixos-unstable
              echo "PR is for a non-release branch, preferred channel is $channel"
          fi
          # Check that the channel exists. It doesn't exist for fresh release branches
          if ! curl -fSs "https://channels.nixos.org/$channel"; then
            # Fall back to nixos-unstable, makes sense for fresh release branches
            echo "Preferred channel $channel could not be fetched, falling back to nixos-unstable"
            channel=nixos-unstable
          fi
          echo "channel=$channel" >> "$GITHUB_ENV"
      - name: Fetching latest version of channel
        run: |
          echo "Fetching latest version of channel $channel"
          rev=2a107bc64b22101157cad353272495add0947a59
          # This is probably the easiest way to get Nix to output the path to a downloaded channel!
          nixpkgs=$(nix-instantiate --find-file nixpkgs -I nixpkgs=https://github.com/NixOS/nixpkgs/tarball/"$rev")
          # This file only exists in channels
          #rev=$(<"$nixpkgs"/.git-revision)
          echo "Channel $channel is at revision $rev"
          echo "nixpkgs=$nixpkgs" >> "$GITHUB_ENV"
          echo "rev=$rev" >> "$GITHUB_ENV"
      - name: Fetching pre-built nixpkgs-check-by-name from the channel
        run: |
          echo "Fetching pre-built nixpkgs-check-by-name from channel $channel at revision $rev"
          # Passing --max-jobs 0 makes sure that we won't build anything
          nix-build "$nixpkgs" -A tests.nixpkgs-check-by-name

          # Print a markdown summary in GitHub actions
          {
            echo "- nixpkgs-check-by-name tool:"
            echo "  - Channel: $channel"
            echo "  - Nixpkgs commit: [$rev](https://github.com/${GITHUB_REPOSITORY}/commit/$rev)"
            echo "  - Store path: \`$(realpath result)\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Running nixpkgs-check-by-name
        run: result/bin/nixpkgs-check-by-name --base "$base" .
